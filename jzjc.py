#!/usr/bin/env python3
from FIRE_routine import *
try:
    '''
    The user should have a paths.py script defining the idiosyncratic
    locations of folders which the methods below need to use.
    E.g. The contents of the user's paths.py might be as follows:
        data = '$HOME/project/data/'
        paper = '$HOME/project/paper' 
    This is necessary because each user and each project will have a
    different file structure
    '''
    import paths
except:
    pass

def calc(galname, max_age=None, num_snaps=1):
    '''
    Calculates jz/jc and j/jc for the given galaxy. The method saves the
    results in the folder specified by paths.data.

    Parameters
    ----------
    galname: str
        The name of the galaxy to analyze, corresponding to an index in the
        dataframe generated by UCI_tools.staudt_tools.init_df
    max_age: float, default None
        Maximum age of stars to analyze, in Gyr, relative to the
        lookback time of the given snapshot. If none is provided, the method
        analyzes all stars.
    
    Returns
    -------
    None
    '''
    import os
    import numpy as np
    import h5py
    #from astropy.cosmology import Planck13
    from astropy.cosmology import FlatLambdaCDM
    from UCI_tools import staudt_tools

    # A dataframe containing information about the m12 simulation files
    gal_df = staudt_tools.init_df()

    print('==================================================================')
    run_name = galname + '_res' + gal_df.loc[galname, 'res']
    if galname in ['Romeo', 'Juliet', 'Romulus', 'Remus', 'Thelma', 'Louise']:
        # 2 hosts for ELVIS runs
        host_num = 2
    else:
        # 1 host for m12 runs
        host_num = 1 
        
    save_path = os.path.join(paths.data, run_name)
    if not os.path.isdir(save_path):
        os.makedirs(save_path)
    print('***Start the routine for ' + run_name + '***')

    output_path = os.path.join('/data17/grenache/aalazar/FIRE/GVB',run_name,
                               'output/hdf5')
    snapdir_paths = get_snapdir_path(output_path)
    for snapdir_path in snapdir_paths[-num_snaps:]: #romeo_juliet has 22 snapshots
        snapdir_num = snapdir_path[-3:] # save the last three digit
        print('========================================')
        print('Start reading the snapshot_'+snapdir_num)
        part, header = read_part(snapdir_path)
        print('Data load!')

        print('H0 = '+str(header['hubble']))
        print('Om0 = '+str(header['omega_matter']))
        print('Build the FlatLambdaCDM based on the above params...')
        cosmo = FlatLambdaCDM(
            H0=header['hubble'], 
            Om0=header['omega_matter'], 
            )
        snap_lbt_raw = cosmo.lookback_time(header['redshift'])
        snap_lbt = np.array((snap_lbt_raw)) / 100.0 # Unit: Gyr
        print('Calculated lookback time for the snapshot: {0:s}'
              .format(snap_lbt_raw.round(3).to_string()))
        
        print('Start calculating the center...')
        host_center, host_velocity = assign_hosts_coordinates_from_particles( 
            part, header, host_number = host_num
            )
        print('Center located for '+ str(host_num)+'host(s)!')
        print(host_center)
        print(host_velocity)
        print('!!!!!!ABOVE check!!!!!!')
        if host_num != host_center.shape[0]:
            raise ValueError('# of host(s) assigned not consistent with the # of the coords/vel got for the host(s)!')
        
        for ii in range(0,host_num):
            
            print('Start calculation for host'+str(ii))
            part['star']['radius'] = header['scalefactor'] * coord_to_r(
                part['star']['position'], 
                cen_deduct = True, 
                cen_coord = host_center[ii],
                ) # Unit: kpc physical
            part['gas']['radius'] = header['scalefactor'] * coord_to_r(
                part['gas']['position'], 
                cen_deduct = True, 
                cen_coord = host_center[ii],
                ) # Unit: kpc physical
            part['dark']['radius'] = header['scalefactor'] * coord_to_r(
                part['gas']['position'], 
                cen_deduct = True, 
                cen_coord = host_center[ii],
                ) # Unit: kpc physical
            r_vs_M_file = get_r_vs_M(part, r_max = 400.0)
            print('Mass profile calculated!')
            print(r_vs_M_file)
            print('!!!!!!!ABOVE!!!!!!!')
            # star_coord_host unit: kpc physical!!!
            star_coord_host = header['scalefactor'] \
                              * (part['star']['position'] - host_center[ii]) 
            star_vel_host = part['star']['velocity'] - host_velocity[ii]
            # CHANGED THE FOLLOWING LINE FROM 10 TO 20 ON JULY 26, 5:47 PM, 
            # grabs stars within 20 kpc
            host_mask = part['star']['radius']<=20.0 
            
            star_jnet_host = calculate_ang_mom(
                part['star']['mass'][host_mask],
                header['scalefactor'] * star_coord_host[host_mask],
                star_vel_host[host_mask],
                )
            r_matrix = cal_rotation_matrix( star_jnet_host ,np.array((0.0,0.0,1.0)))
            print('ROTATION MATRIX???')
            print(r_matrix)
            print('!!!!!!!ABOVE!!!!!!!')
            star_coord_host = rotate_matrix(star_coord_host,r_matrix)
            star_vel_host = rotate_matrix(star_vel_host,r_matrix)

            print('Start calculating Jz/Jc for host'+ str(ii))
            JzJc_host, trash = get_Jz_over_Jc(
                part['star']['radius'][host_mask],
                part['star']['position'][host_mask],
                star_coord_host[host_mask],
                star_vel_host[host_mask],
                r_vs_M_file,
                recal_jnet = False,
                )
            print('Jz/Jc for host'+ str(ii)+' done!')


            print('Start calculating J/Jc for host'+ str(ii))
            JJc_host, trash = get_J_over_Jc(
                part['star']['radius'][host_mask],
                part['star']['position'][host_mask],
                star_coord_host[host_mask],
                star_vel_host[host_mask],
                r_vs_M_file,
                recal_jnet = False,
                )
            print('J/Jc for host'+ str(ii)+' done!')

            print('All calculation done. Start saving data now...')

            print('Select the particles to save based on SFT...')
            sft_lbt = np.array((cosmo.lookback_time(
                1.0 / part['star']['sft_a'][host_mask] - 1.0 ))) / 100.0
            if max_age is not None:
                print('(Only save particles younger than {0:0.0f} Gyr)'
                      .format(max_age))
                # changed .1 to .5, july 31 7:33 pm, only grabs stars w/sft <500Myr
                young_mask = ( sft_lbt <= (snap_lbt+0.5) ) 
                # I think the previous line is actually only grabbing stars 
                # w/sft
                # within 5 Myr of the given lookback time, not 500 Myr -PS

                # Max stellar age string to use in the filename:
                max_age_str = '_{0:0.0f}Myr'.format(max_age * 100.)
            else:
                young_mask = np.repeat(True, len(sft_lbt))
                # Don't add any max stellar age info to the filename:
                max_age_str = ''
            print('Out of '+ str( host_mask[host_mask].shape[0] ) +' host particles:')
            print('!!!!! # of particles saved: '+ str(young_mask[young_mask].shape[0]) + ' !!!!!' )
            
            fff = os.path.join(save_path, 
                               'id_jzjc_jjc_' \
                                   + snapdir_num + '_host' + str(ii)[0] \
                                   + '_20kpc' + max_age_str \
                                   + '.hdf5'
                  )
            print('Saving data in:'+fff)
            
            df = h5py.File(fff,'w')
            df.create_dataset(
                'id', 
                data=part['star']['id'][host_mask][young_mask]
            ) 
            
            df.create_dataset(
                'sft_a', 
                data=part['star']['sft_a'][host_mask][young_mask]
            ) 
            df.create_dataset('sft_Gyr', data=sft_lbt[young_mask])

            df.create_dataset('jzjc', data=JzJc_host[young_mask])
            df.create_dataset('jjc', data=JJc_host[young_mask])
            
            df.create_dataset('masses', 
                              data=part['star']['mass'][host_mask][young_mask])

            df.create_dataset('host_center', data = host_center[ii])
            df.close()
    return None

def getoptions():
    '''
    Get the options specified by the user when running the script from
    terminal. Most importantly, the user specifies the galaxy to analyze. The
    user can also specify the maximum age of stars to analyze.

    Returns
    -------
    args: argparse.Namespace
        An object containing the options specified by the user
    '''
    import argparse
    usage = '%(prog)s galname'
    desc = 'Calculate jz/jc and j/jc for a given galaxy'
    parser = argparse.ArgumentParser(usage=usage, description=desc)
    parser.add_argument('galname', nargs=1, 
                        help='Name of the galaxy to analyze')
    parser.add_argument(
        '-m', 
        '--max-age', 
        default=None, 
        dest='max_age',
        help=('Maximum age of stars to analyze, in Gyr, relative to the'
              ' lookback time of the given snapshot.')
    )
    parser.add_argument(
        '-n',
        '--num-snaps',
        default=1,
        type=int,
        dest='num_snaps',
        help=('The number of snapshots to save, starting with snapshot 600'
              ' (z=0) and going backwards in time. The default is 1.')
    )
    args = parser.parse_args()
    return args

def main():
    args = getoptions()
    galname = args.galname[0]
    max_age = args.max_age
    num_snaps = args.num_snaps

    calc(galname, max_age, num_snaps)

    return None

if __name__ == '__main__':
    main()
