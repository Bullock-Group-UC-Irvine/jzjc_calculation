#!/usr/bin/env python3
from FIRE_routine import *

try:
    '''
    The user should have a paths.py script defining the idiosyncratic
    locations of folders which the methods below need to use.
    E.g. The contents of the user's paths.py might be as follows:
        data = '$HOME/project/data/'
        paper = '$HOME/project/paper' 
    This is necessary because each user and each project will have a
    different file structure
    '''
    import paths
except:
    raise ImportError(
        'You need a paths.py file in your `jzjc_calculation` folder to specify'
        ' where certain directories are for you. For example, one line of'
        ' paths.py might specify where you want to save your results with\n'
        '    data = \'/data17/grenache/your_username/\''
    )

def calc(galname, max_age=None, num_snaps=1, halo_source='rockstar'):
    '''
    Calculates jz/jc and j/jc for the given galaxy. The method saves the
    results in the folder specified by paths.data.

    If `galname` is an ELVIS galaxy, the code analyses both galaxies in the
    pair. The resulting data file specifies 'halo0' for the larger galaxy,
    'host1' for the smaller.

    Parameters
    ----------
    galname: str
        The name of the galaxy to analyze, corresponding to an index in the
        dataframe generated by UCI_tools.staudt_tools.init_df
    max_age: float, default: None
        Maximum age of stars to analyze, in Gyr, relative to the
        lookback time of the given snapshot. If none is provided, the method
        analyzes all stars.
    halo_source: {'rockstar', 'particles'}, default: 'rockstar'
        The source for the information about the halo, such as its position.
    Returns
    -------
    None
    '''
    if halo_source not in ['rockstar', 'particles']:
        raise ValueError(
            'Unexpected argument for `halo_source`. Choices are \'rockstar\''
            ' and \'particles\''
        )
    import os
    import numpy as np
    import h5py
    #from astropy.cosmology import Planck13
    from astropy.cosmology import FlatLambdaCDM
    from UCI_tools import staudt_tools
    from UCI_tools import tools as uci

    # A dataframe containing information about the m12 simulation files
    gal_df = staudt_tools.init_df()

    print('==================================================================')
    run_name = 'm12' + gal_df.loc[galname, 'fsuffix'] \
               + '_res' + gal_df.loc[galname, 'res']
    if galname in ['Romeo', 'Juliet', 'Romulus', 'Remus', 'Thelma', 'Louise']:
        # 2 hosts for ELVIS runs
        # (If any ELVIS halo is specified, the code analyses both halos in the
        # pair.)
        host_num = 2
    else:
        # 1 host for m12 runs
        host_num = 1 
        
    save_path = os.path.join(paths.data, run_name)
    if not os.path.isdir(save_path):
        os.makedirs(save_path)
    print('***Start the routine for ' + run_name + '***')

    output_path = os.path.join(
        '/data17/grenache/omyrtaj/FIRE/',
        run_name,
        'output'
    )
    snapdir_paths = get_snapdir_path(output_path)
    for snapdir_path in snapdir_paths[-num_snaps:]: 
        snapdir_num = snapdir_path[-3:] # save the last three digit
        print('========================================')
        print('Start reading the snapshot_'+snapdir_num)
        part, header = read_part(snapdir_path)
        print('Data load!')

        print('H0 = '+str(header['hubble']))
        print('Om0 = '+str(header['omega_matter']))
        print('Build the FlatLambdaCDM based on the above params...')
        cosmo = FlatLambdaCDM(
            H0=header['hubble'], 
            Om0=header['omega_matter'], 
            )
        snap_lbt_raw = cosmo.lookback_time(header['redshift'])
        snap_lbt = np.array((snap_lbt_raw)) / 100.0 # Unit: Gyr
        print('Calculated redshift for the snapshot: ' 
              + str(header['redshift']))
        print('Calculated lookback time for the snapshot: {0:s}'
              .format(snap_lbt_raw.round(3).to_string()))
        
        print('Start calculating the center...')
        if halo_source == 'particles':
            host_info = assign_hosts_coordinates_from_particles( 
                part, header, host_number = host_num
            )
            host_center, host_velocity = host_info
        elif halo_source == 'rockstar':
            halo = h5py.File(
                '/data17/grenache/omyrtaj/FIRE/'
                    + run_name
                    + '/halo/rockstar_dm/catalog_hdf5/halo_'
                    + snapdir_num 
                    + '.hdf5', 
                'r'
            )
            f_star = h5py.File(
                '/data17/grenache/omyrtaj/FIRE/'
                    + run_name
                    + '/halo/rockstar_dm/catalog_hdf5/star_'
                    + snapdir_num
                    + '.hdf5',
                'r'
            )
            halo_pos = np.array(halo['position'])
            halo_vel = np.array(halo['velocity'])
            if 'host.index' in halo.keys():
                # host1 is the larger host.
                host1_ind = np.array(halo['host.index'])[0]
                # host2 is the smaller host.
                host2_ind = np.array(halo['host2.index'])[0]
            else:
                # If the halo file doesn't tell us what the two main hosts are,
                # we'll need to find them ourselves
                ms_hals = halo['mass.vir'][:]
                is_sorted = np.argsort(ms_hals) # sorted indices
                host1_ind = is_sorted[-1] # largest host
                host2_ind = is_sorted[-2] # second largest

            # (`host_num` is determined above by the target galaxy's name.)
            if host_num == 1:
                host_center = np.array([halo_pos[host1_ind]])
                host_velocity = np.array([halo_vel[host1_ind]])
            elif host_num == 2:
                host_center = np.array([halo_pos[host1_ind], 
                                        halo_pos[host2_ind]])
                host_velocity = np.array([halo_vel[host1_ind], 
                                          halo_vel[host2_ind]])
            r90_star_rockstar_arr = np.array(f_star['star.radius.90'])

            f_star.close()

        print('Center located for '+ str(host_num)+' host(s)!')
        print(host_center)
        print(host_velocity)
        print('!!!!!!ABOVE check!!!!!!')
        if host_num != host_center.shape[0]:
            raise ValueError('# of host(s) assigned not consistent with the # of the coords/vel got for the host(s)!')
        
        for ii in range(0,host_num):
            print('Start calculation for host'+str(ii))
            part['star']['radius'] = header['scalefactor'] * coord_to_r(
                part['star']['position'], 
                cen_deduct = True, 
                cen_coord = host_center[ii],
                ) # Unit: kpc physical
            part['gas']['radius'] = header['scalefactor'] * coord_to_r(
                part['gas']['position'], 
                cen_deduct = True, 
                cen_coord = host_center[ii],
                ) # Unit: kpc physical
            part['dark']['radius'] = header['scalefactor'] * coord_to_r(
                part['dark']['position'], 
                cen_deduct = True, 
                cen_coord = host_center[ii],
                ) # Unit: kpc physical
            r_vs_M_file = get_r_vs_M(part, r_max = 400.0)
            print('Mass profile calculated!')
            print(r_vs_M_file)
            print('!!!!!!!ABOVE!!!!!!!')

            v_circ_vs_r = get_circ_vel(r_vs_M_file)
            print('Circular velocity profile calculated!')
            accel_vs_r = get_accel(r_vs_M_file)
            print('Acceleration profile calculated!')
            

            if halo_source == 'rockstar':
                if ii == 0:
                    m_vir = np.array(halo['mass.vir'])[host1_ind]
                    r90_star_rockstar = r90_star_rockstar_arr[host1_ind]
                elif ii == 1:
                    m_vir = np.array(halo['mass.vir'])[host2_ind]
                    r90_star_rockstar = r90_star_rockstar_arr[host2_ind]
                z = 1/header['scalefactor'] - 1
                r_vir = virial_radius(
                    m_vir, 
                    z, 
                    header['omega_matter'], 
                    header['omega_lambda'], 
                    header['hubble']
                )
                print('Virial radius calculated: ' + str(r_vir))
                r90_mask = part['star']['radius'] < 0.1*r_vir
                r90_star = get_r90(part['star']['radius'][r90_mask],
                                       part['star']['mass'][r90_mask],
                                       np.sum(part['star']['mass']))
                print('r90_star (using 0.1 r_vir): ', r90_star)
                print('r90_star (from star catalog): ', r90_star_rockstar)
                r_peak_over_r90 = get_r_peak_over_r90(
                    v_circ_vs_r[0], 
                    v_circ_vs_r[1], 
                    r90_star
                )
                r_peak_over_r90_rockstar = get_r_peak_over_r90(
                    v_circ_vs_r[0], 
                    v_circ_vs_r[1], 
                    r90_star_rockstar
                )
                print('r_peak/r90: ', r_peak_over_r90)
                print('r_peak_over_r90_rockstar: ', r_peak_over_r90_rockstar)

            # star_coord_host unit: kpc physical!!!
            star_coord_host = header['scalefactor'] \
                              * (part['star']['position'] - host_center[ii]) 
            star_vel_host = part['star']['velocity'] - host_velocity[ii]
            # CHANGED THE FOLLOWING LINE FROM 10 TO 20 ON JULY 26, 5:47 PM, 
            # grabs stars within 20 kpc
            host_mask = part['star']['radius']<=20.0 
            
            star_jnet_host = calculate_ang_mom(
                part['star']['mass'][host_mask],
                header['scalefactor'] * star_coord_host[host_mask],
                star_vel_host[host_mask],
                )
            r_matrix = cal_rotation_matrix( star_jnet_host ,np.array((0.0,0.0,1.0)))
            print('ROTATION MATRIX???')
            print(r_matrix)
            print('!!!!!!!ABOVE!!!!!!!')
            star_coord_host = rotate_matrix(star_coord_host,r_matrix)
            star_vel_host = rotate_matrix(star_vel_host,r_matrix)

            print('Starting v_phi calculation: ')
            cyl_vels = uci.calc_cyl_vels(star_vel_host, star_coord_host)
            v_dot_phihat = cyl_vels['v_dot_phihat']

            print('Start calculating Jz/Jc for host'+ str(ii))
            JzJc_host, trash = get_Jz_over_Jc(
                part['star']['radius'][host_mask],
                part['star']['position'][host_mask],
                star_coord_host[host_mask],
                star_vel_host[host_mask],
                r_vs_M_file,
                recal_jnet = False,
                )
            print('Jz/Jc for host'+ str(ii)+' done!')


            print('Start calculating J/Jc for host'+ str(ii))
            JJc_host, trash = get_J_over_Jc(
                part['star']['radius'][host_mask],
                part['star']['position'][host_mask],
                star_coord_host[host_mask],
                star_vel_host[host_mask],
                r_vs_M_file,
                recal_jnet = False,
                )
            print('J/Jc for host'+ str(ii)+' done!')

            fe_over_h = uci.fe_over_h_ratios(
                part['star']['metallicity'][:,0][host_mask], #added may 2
                part['star']['metallicity'][:,1][host_mask],
                part['star']['metallicity'][:,10][host_mask]
            )
            print('Done calculating [Fe/H]')
            mg_over_fe = mg_over_fe_ratios(
                part['star']['metallicity'][:,6][host_mask],
                part['star']['metallicity'][:,10][host_mask]
            )
            print('Done calculating [Mg/Fe]')
            o_over_fe = o_over_fe_ratios(
                part['star']['metallicity'][:,4][host_mask],
                part['star']['metallicity'][:,10][host_mask]
            )
            print('Done calculating [O/Fe]')

            print('All calculation done. Start saving data now...')

            print('Select the particles to save based on SFT...')
            sft_lbt = np.array((cosmo.lookback_time(
                1.0 / part['star']['sft_a'][host_mask] - 1.0 ))) / 100.0
            if max_age is not None:
                print('(Only save particles younger than {0:0.0f} Gyr)'
                      .format(max_age))
                # changed .1 to .5, july 31 7:33 pm, only grabs stars 
                # w/sft <500Myr
                young_mask = ( sft_lbt <= (snap_lbt+0.5) ) 
                # I think the previous line is actually only grabbing stars 
                # w/sft
                # within 5 Myr of the given lookback time, not 500 Myr -PS

                # Max stellar age string to use in the filename:
                max_age_str = '_{0:0.0f}Myr'.format(max_age * 1.e3)
            else:
                young_mask = np.repeat(True, len(sft_lbt))
                # Don't add any max stellar age info to the filename:
                max_age_str = ''
            print('Out of '+ str( host_mask[host_mask].shape[0] ) +' host particles:')
            print('!!!!! # of particles saved: '+ str(young_mask[young_mask].shape[0]) + ' !!!!!' )
            
            if halo_source == 'rockstar':
                source_str = '_rockstar'
            elif halo_source == 'particles':
                source_str = '_com' # center of mass
            # The file name specified 'host0' for the larger host, 'host1' for
            # the smaller.
            fff = os.path.join(save_path, 
                               'id_jzjc_jjc_' \
                                   + snapdir_num + '_host' + str(ii)[0] \
                                   + '_20kpc' + max_age_str \
                                   + source_str
                                   + '.hdf5'
            )
            print('Saving data in:'+fff)
            
            df = h5py.File(fff,'w')

            ###################################################################
            # I don't know what `r_vs_M_file` is. Should this be masked with
            # `young_mask` and `host_mask` like the other datasets? -PS
            df.create_dataset('r_vs_M_file', data = r_vs_M_file)
            ###################################################################

            df.create_dataset(
                'id', 
                data=part['star']['id'][host_mask][young_mask]
            ) 
            df.create_dataset(
                'mass', 
                data=part['star']['mass'][host_mask][young_mask]
            )

            ###################################################################
            # Similar question: Should these be masked? -PS
            if halo_source == 'rockstar':
                df.create_dataset('r_vir', data = r_vir)
                df.create_dataset('r90_star', data = r90_star)
                df.create_dataset('r_peak_over_r90', data = r_peak_over_r90)
                df.create_dataset(
                    'r90_star_rockstar', 
                    data = r90_star_rockstar
                )
                df.create_dataset(
                    'r_peak_over_r90_rockstar', 
                    data=r_peak_over_r90_rockstar
                )
            df.create_dataset('fe_over_h', data=fe_over_h)#[young_mask])
            df.create_dataset('mg_over_fe', data = mg_over_fe)
            df.create_dataset('o_over_fe', data = o_over_fe)
            ###################################################################
            
            df.create_dataset(
                'sft_a', 
                data=part['star']['sft_a'][host_mask][young_mask]
            ) 
            df.create_dataset('sft_Gyr', data=sft_lbt[young_mask])
            df.create_dataset('jzjc', data=JzJc_host[young_mask])
            df.create_dataset('jjc', data=JJc_host[young_mask])
            df.create_dataset('host_center', data = host_center[ii])

            ###################################################################
            # Similar question: Should these be masked with `young_mask`? -PS
            df.create_dataset('v_dot_phihat', data = v_dot_phihat[host_mask])
            df.create_dataset('v_circ_vs_r', data = v_circ_vs_r)
            df.create_dataset('accel_vs_r', data = accel_vs_r)       
            df.create_dataset(
                'star_coord_host', 
                data = star_coord_host[host_mask]
            )
            df.create_dataset('star_vel_host', data = star_vel_host[host_mask])
            ###################################################################

            df.close()
        halo.close()
    return None

def getoptions():
    '''
    Get the options specified by the user when running the script from
    terminal. Most importantly, the user specifies the galaxy to analyze. The
    user can also specify the maximum age of stars to analyze.

    Returns
    -------
    args: argparse.Namespace
        An object containing the options specified by the user
    '''
    import argparse
    desc = 'Calculate jz/jc and j/jc for a given galaxy'
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument(
        'galname', 
        nargs=1, 
        help=('Name of the galaxy to analyze. Latte galaxies'
              ' start with a lowercase \'m\', e.g. m12i. ELVIS'
              ' galaxies start with a capital letter, e.g. '
              ' Romeo.')
    )
    parser.add_argument(
        '-m', 
        '--max-age', 
        default=None, 
        dest='max_age',
        help=('Maximum age of stars to analyze, in Gyr, relative to the'
              ' lookback time of the given snapshot. The default is to include'
              ' all stars.')
    )
    parser.add_argument(
        '-n',
        '--num-snaps',
        default=1,
        type=int,
        dest='num_snaps',
        help=('The number of snapshots to save, starting with snapshot 600'
              ' (z=0) and going backwards in time. The default is 1.')
    )
    parser.add_argument(
        '-s',
        '--halo-source',
        default='rockstar',
        type=str,
        dest='halo_source',
        help=('The source for halo information. Choices are \'rockstar\' or'
              ' \'particles\', the latter of which finds the center of mass'
              ' of the particles. The default is \'rockstar\'')
    )
    args = parser.parse_args()
    return args

def main():
    args = getoptions()
    galname = args.galname[0]
    max_age = args.max_age
    if max_age is not None:
        max_age = float(max_age)
    num_snaps = args.num_snaps
    halo_source = args.halo_source

    calc(galname, max_age, num_snaps, halo_source)

    return None

if __name__ == '__main__':
    main()
